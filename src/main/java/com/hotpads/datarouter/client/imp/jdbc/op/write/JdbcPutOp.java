package com.hotpads.datarouter.client.imp.jdbc.op.write;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.List;

import com.hotpads.datarouter.client.imp.hibernate.util.JdbcTool;
import com.hotpads.datarouter.client.imp.jdbc.node.JdbcNode;
import com.hotpads.datarouter.client.imp.jdbc.op.BaseJdbcOp;
import com.hotpads.datarouter.config.Config;
import com.hotpads.datarouter.config.Isolation;
import com.hotpads.datarouter.config.PutMethod;
import com.hotpads.datarouter.exception.DataAccessException;
import com.hotpads.datarouter.exception.DuplicateEntrySqlException;
import com.hotpads.datarouter.serialize.fielder.DatabeanFielder;
import com.hotpads.datarouter.storage.databean.Databean;
import com.hotpads.datarouter.storage.field.Field;
import com.hotpads.datarouter.storage.field.FieldTool;
import com.hotpads.datarouter.storage.field.encoding.AutoGeneratedField;
import com.hotpads.datarouter.storage.field.encoding.AutoGeneratedField.AutoGeneratedType;
import com.hotpads.datarouter.storage.key.primary.PrimaryKey;
import com.hotpads.datarouter.util.core.DrCollectionTool;
import com.hotpads.util.core.java.ReflectionTool;
import com.hotpads.util.core.number.RandomTool;
import com.mysql.jdbc.MysqlErrorNumbers;

public class JdbcPutOp<
		PK extends PrimaryKey<PK>,
		D extends Databean<PK,D>,
		F extends DatabeanFielder<PK,D>> 
extends BaseJdbcOp<Void>{
	
	public static final PutMethod DEFAULT_PUT_METHOD = PutMethod.SELECT_FIRST_OR_LOOK_AT_PRIMARY_KEY;
	private static final int MAX_RANDOM_ID_GENERATION_ATTEMPTS = 10;
	
	private final JdbcNode<PK,D,F> node;
	private final Collection<D> databeans;
	private final Config config;
	
	public JdbcPutOp(JdbcNode<PK,D,F> node, Collection<D> databeans, Config config) {
		super(node.getDatarouterContext(), node.getClientNames(), getIsolation(config), 
				shouldAutoCommit(databeans, config));
		this.node = node;
		this.databeans = databeans;
		this.config = config;
	}
	
	@Override
	public Void runOnce(){
		Connection connection = getConnection(node.getClientName());
		for(D databean : DrCollectionTool.nullSafe(databeans)){
			jdbcPutUsingMethod(connection, databean, config, DEFAULT_PUT_METHOD);
		}
		return null;
	}
	

	
	/******************** private **********************************************/
	
	private static Isolation getIsolation(Config config){
		if(config==null){ return Config.DEFAULT_ISOLATION; }
		return config.getIsolationOrUse(Config.DEFAULT_ISOLATION);
	}
	
	/*
	 * mirror of of above "putUsingMethod"
	 */
	private static boolean shouldAutoCommit(Collection<? extends Databean<?,?>> databeans, final Config config){
		if(DrCollectionTool.size(databeans) > 1){ return false; }
		PutMethod putMethod = DEFAULT_PUT_METHOD;
		if(config!=null && config.getPutMethod()!=null){
			putMethod = config.getPutMethod();
		}
		if(PutMethod.INSERT_OR_BUST == putMethod){
			return true;
		}else if(PutMethod.UPDATE_OR_BUST == putMethod){
			return true;
		}else if(PutMethod.INSERT_OR_UPDATE == putMethod){
			return false;
		}else if(PutMethod.UPDATE_OR_INSERT == putMethod){
			return false;
		}else if(PutMethod.MERGE == putMethod){
			return false;
		}else{
			return false;
		}
	}
	
	private boolean needsIdGenerated(Databean<PK,D> databean){
		List<Field<?>> fields = databean.getKeyFields();
		for (Field<?> f : fields) {
			if (f instanceof AutoGeneratedField) {
				AutoGeneratedField<?> autoGeneratedField = (AutoGeneratedField<?>) f;
				if (autoGeneratedField.getAutoGeneratedType() != null && autoGeneratedField.getValue() == null) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	private void setAutoGeneratedId(D databean, Long id){
		String autoGeneratedFieldName = node.getFieldInfo().getAutogeneratedFieldName();
		Class<?> primaryKeyClass = node.getFieldInfo().getPrimaryKeyClass();
		java.lang.reflect.Field autogeneratedField = ReflectionTool.getCachedDeclaredFieldFromHierarchy(
				primaryKeyClass, autoGeneratedFieldName);
		ReflectionTool.set(autogeneratedField, databean.getKey(), id);
	}
	
	private void jdbcPutUsingMethod(Connection connection, D databean, final Config config,
			PutMethod defaultPutMethod){
		PutMethod putMethod = defaultPutMethod;
		if(config!=null && config.getPutMethod()!=null){
			putMethod = config.getPutMethod();
		}
		boolean generateId = node.getFieldInfo().getAutoGeneratedType() != null && needsIdGenerated(databean);
		if(generateId){
			if(node.getFieldInfo().getAutoGeneratedType().equals(AutoGeneratedType.RANDOM)){
				int attempts = 0;
				while(true){
					try{
						setAutoGeneratedId(databean, RandomTool.nextPositiveLong());
						jdbcInsert(connection, databean);
						break;
					}catch(DuplicateEntrySqlException e){
						if(attempts++ >= MAX_RANDOM_ID_GENERATION_ATTEMPTS){
							throw new DataAccessException("error inserting into "+node.getTableName(),e);
						}
					}
				}
			}else{ // The RDBMS will assign the id.
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.INSERT_OR_BUST == putMethod){
			jdbcInsert(connection, databean);
		}else if(PutMethod.UPDATE_OR_BUST == putMethod){
			jdbcUpdate(connection, databean);
		}else if(PutMethod.INSERT_OR_UPDATE == putMethod){
			try{
				jdbcInsert(connection, databean);
			}catch(RuntimeException e){  
				//TODO this will not work inside a txn if not all of the rows already exist
				jdbcUpdate(connection, databean);
			}
		}else if(PutMethod.UPDATE_OR_INSERT == putMethod){
			try{
				jdbcUpdate(connection, databean);
			}catch(RuntimeException e){
				//TODO this will not work inside a txn if some of the rows already exist
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.MERGE == putMethod){
			//not really a jdbc concept, but usually an update (?)
			try{
				jdbcUpdate(connection, databean);
			}catch(RuntimeException e){
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.INSERT_IGNORE == putMethod){
			jdbcInsert(connection, databean, true, false);
		}else if(PutMethod.INSERT_ON_DUPLICATE_UPDATE == putMethod){
			jdbcInsert(connection, databean, false, true);
		}else{
			//TODO weird to call back to node.exists
			boolean alreadyExists = node.exists(databean.getKey(), null);
			if(alreadyExists){//select before update like hibernate's saveOrUpdate
				jdbcUpdate(connection, databean);
			}else{
				jdbcInsert(connection, databean);
			}
		}
	}

	private void jdbcInsert(Connection connection, D databean){
		jdbcInsert(connection, databean, false, false);
	}
	
	private void jdbcInsert(Connection connection, D databean, boolean ignore, boolean onDuplicateKeyUpdate){
//		logger.warn("JDBC Insert");
		StringBuilder sb = new StringBuilder();
		sb.append("insert");
		if(ignore){
			sb.append(" ignore");
		}
		sb.append(" into "+node.getTableName()+" (");
		FieldTool.appendCsvColumnNames(sb, node.getFieldInfo().getFields());
		sb.append(") values (");
		JdbcTool.appendCsvQuestionMarks(sb, DrCollectionTool.size(node.getFieldInfo().getFields()));
		sb.append(")");
		if(onDuplicateKeyUpdate){
			sb.append(" on duplicate key update ");
			boolean doneOne = false;
			for(Field<?> field : node.getFieldInfo().getFields()){
				if(doneOne) { sb.append(","); }
				sb.append(field.getColumnName() + "=VALUES(" + field.getColumnName() + ")");
				doneOne = true;
			}
		}
		try{
			PreparedStatement ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
			int parameterIndex = 1;//one based
			List<Field<?>> fields = node.getFieldInfo().getFieldsWithValues(databean);
			for(Field<?> field : fields){
				field.setPreparedStatementValue(ps, parameterIndex);
				++parameterIndex;
			}
			ps.execute();
			// set autogenerated id
			if(node.getFieldInfo().isManagedAutoGeneratedId()){
				//Retrieve the generated id from DB
				ResultSet resultSet = ps.getGeneratedKeys();
				resultSet.next();
				Long id = resultSet.getLong(1);
				//set the id
				setAutoGeneratedId(databean, id);
			}
		}catch(Exception e){
			if(e instanceof SQLException && ((SQLException) e).getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){
				throw new DuplicateEntrySqlException(e);
			}
			throw new DataAccessException("error inserting into "+node.getTableName(),e);
		}
	}
	
	private void jdbcUpdate(Connection connection, D databean){
		//it doesn't make sense to update a row without PK fields.  updating the PK will move the row
		List<Field<?>> emptyNonKeyFields = node.getFieldInfo().getNonKeyFields();
		if(DrCollectionTool.isEmpty(emptyNonKeyFields)){ return; }
		
//		logger.warn("JDBC update");
		StringBuilder sb = new StringBuilder();
		sb.append("update "+node.getTableName()+" set ");
		FieldTool.appendSqlUpdateClauses(sb, emptyNonKeyFields);
		sb.append(" where ");
		sb.append(FieldTool.getSqlNameValuePairsEscapedConjunction(databean.getKeyFields()));
		int numUpdated;
		try{
			PreparedStatement ps = connection.prepareStatement(sb.toString());
			int parameterIndex = 1;
			List<Field<?>> nonKeyFields = node.getFieldInfo().getNonKeyFieldsWithValues(databean);
			for(Field<?> field : nonKeyFields){
				field.setPreparedStatementValue(ps, parameterIndex);
				++parameterIndex;
			}
			numUpdated = ps.executeUpdate();
		}catch(SQLException e){
			throw new DataAccessException("error updating "+node.getTableName(), e);
		}
		if(numUpdated!=1){
			throw new DataAccessException(node.getTableName()+" row "+databean.getKey().toString()
					+" not found so could not be updated");
		}
	}
}
