package com.hotpads.datarouter.serialize.fieldcache;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Preconditions;
import com.hotpads.datarouter.client.ClientId;
import com.hotpads.datarouter.client.imp.jdbc.ddl.domain.MySqlCharacterSet;
import com.hotpads.datarouter.client.imp.jdbc.ddl.domain.MySqlCollation;
import com.hotpads.datarouter.node.NodeParams;
import com.hotpads.datarouter.serialize.fielder.DatabeanFielder;
import com.hotpads.datarouter.serialize.fielder.PrimaryKeyFielder;
import com.hotpads.datarouter.storage.databean.Databean;
import com.hotpads.datarouter.storage.field.Field;
import com.hotpads.datarouter.storage.field.FieldSet;
import com.hotpads.datarouter.storage.field.FieldTool;
import com.hotpads.datarouter.storage.field.SimpleFieldSet;
import com.hotpads.datarouter.storage.field.encoding.FieldGeneratorType;
import com.hotpads.datarouter.storage.key.primary.EntityPrimaryKey;
import com.hotpads.datarouter.storage.key.primary.PrimaryKey;
import com.hotpads.datarouter.storage.prefix.EmptyScatteringPrefix;
import com.hotpads.datarouter.storage.prefix.ScatteringPrefix;
import com.hotpads.datarouter.util.core.DrByteTool;
import com.hotpads.datarouter.util.core.DrCollectionTool;
import com.hotpads.datarouter.util.core.DrIterableTool;
import com.hotpads.datarouter.util.core.DrStringTool;
import com.hotpads.util.core.bytes.StringByteTool;
import com.hotpads.util.core.java.ReflectionTool;

public class DatabeanFieldInfo<
		PK extends PrimaryKey<PK>,
		D extends Databean<PK,D>,
		F extends DatabeanFielder<PK,D>> {
	private static Logger logger = LoggerFactory.getLogger(DatabeanFieldInfo.class);

	private static final byte ENTITY_PREFIX_TERMINATOR = 0;

	//these 4 fields only apply to physical nodes, but cleanest to add them here for now
	private ClientId clientId;
	private String tableName;
	private String packagedTableName;
	private String explicitNodeName;

	private Class<PK> primaryKeyClass;
	private PK samplePrimaryKey;
	private Supplier<D> databeanSupplier;
	private D sampleDatabean;
	private String keyFieldName;
	private java.lang.reflect.Field keyJavaField;
	private Map<String,List<Field<?>>> indexes;
	private Map<String,List<Field<?>>> uniqueIndexes;
	private MySqlCollation collation;
	private MySqlCharacterSet characterSet;

	private boolean entity = false;
	private String entityNodePrefix;
	private byte[] entityNodeColumnPrefixBytes;
	private List<Field<?>> ekFields;//for accessing the EK directly
	private List<Field<?>> ekPkFields;//for accessing the EK via a PK
	private List<Field<?>> postEkPkKeyFields;

	private Class<? extends ScatteringPrefix> scatteringPrefixClass;
	private ScatteringPrefix sampleScatteringPrefix;
	private List<Field<?>> scatteringPrefixFields;

	private Supplier<F> fielderSupplier;
	private F sampleFielder;
	private Class<PrimaryKeyFielder<PK>> primaryKeyFielderClass;
	private PrimaryKeyFielder<PK> samplePrimaryKeyFielder;

	private boolean fieldAware;
	private FieldGeneratorType autoGeneratedType;
	private String autoGeneratedFieldName;
	//these hold separate deep-copies of the fields
	private List<Field<?>> primaryKeyFields;//no prefixes
	private List<Field<?>> prefixedPrimaryKeyFields;//no prefixes
	private List<Field<?>> nonKeyFields;
	private List<Field<?>> fields;//PK fields will have prefixes in this Collection


	private Map<String,Field<?>> primaryKeyFieldByName = new HashMap<>();
	private Map<String,Field<?>> nonKeyFieldByColumnName = new HashMap<>();
	private Map<String,Field<?>> fieldByColumnName = new HashMap<>();
	private Map<String,Field<?>> fieldByPrefixedName = new HashMap<>();

	private List<String> fieldNames = new ArrayList<>();
	private List<java.lang.reflect.Field> reflectionFields = new ArrayList<>();
	private Map<String,java.lang.reflect.Field> reflectionFieldByName = new HashMap<>();


	public DatabeanFieldInfo(String nodeName, NodeParams<PK,D,F> params){
		this.databeanSupplier = params.getDatabeanSupplier();
		this.sampleDatabean = databeanSupplier.get();
		this.primaryKeyClass = this.sampleDatabean.getKeyClass();
		this.samplePrimaryKey = ReflectionTool.create(primaryKeyClass);
		this.keyFieldName = sampleDatabean.getKeyFieldName();
		this.fielderSupplier = params.getFielderSupplier();
		this.fieldAware = fielderSupplier != null;
		this.autoGeneratedType = detectAutoGeneratedType();

		try{
			/*
			 * TODO remove duplicate logic below, but watch out for handling of non fieldAware databeans
			 */
			this.primaryKeyFields = samplePrimaryKey.getFields();
			this.prefixedPrimaryKeyFields = sampleDatabean.getKeyFields();
			addPrimaryKeyFieldsToCollections();
			if(fielderSupplier==null){
				Preconditions.checkArgument(!fieldAware, nodeName+" is field aware but has no Fielder");
				if(fieldAware){
					throw new IllegalArgumentException("could not instantiate "+nodeName
							+", fieldAware databean node must specify fielder class");
				}
				this.scatteringPrefixClass = EmptyScatteringPrefix.class;
			}else{
				this.sampleFielder = fielderSupplier.get();
				//TODO remove the cast after fixing the DatabeanFielder interface and changing all databeans
				this.primaryKeyFielderClass = (Class<PrimaryKeyFielder<PK>>)sampleFielder.getKeyFielderClass();
				this.samplePrimaryKeyFielder = ReflectionTool.create(primaryKeyFielderClass);
				this.primaryKeyFields = samplePrimaryKeyFielder.getFields(sampleDatabean.getKey());
				this.prefixedPrimaryKeyFields = sampleFielder.getKeyFields(sampleDatabean);

				Preconditions.checkArgument(fieldAware, nodeName+" specified a Fielder but is not FieldAware");
				this.fields = sampleFielder.getFields(sampleDatabean);//make sure there is a PK or this will NPE
				addFieldsToCollections();
				//only do these if the previous fields succeeded
				this.nonKeyFields = sampleFielder.getNonKeyFields(sampleDatabean);
				addNonKeyFieldsToCollections();
				this.indexes = sampleFielder.getIndexes(sampleDatabean);
				this.uniqueIndexes = sampleFielder.getUniqueIndexes(sampleDatabean);
				this.characterSet = sampleFielder.getCharacterSet();
				this.collation = sampleFielder.getCollation();
				this.scatteringPrefixClass = sampleFielder.getScatteringPrefixClass();
			}
			this.sampleScatteringPrefix = ReflectionTool.create(scatteringPrefixClass);
			this.scatteringPrefixFields = sampleScatteringPrefix.getScatteringPrefixFields(samplePrimaryKey);
		}catch(Exception probablyNoPkInstantiated){
			throw new IllegalArgumentException("could not instantiate "+nodeName, probablyNoPkInstantiated);
		}

		//entity stuff
		this.entity = DrStringTool.notEmpty(params.getEntityNodePrefix());
		if(entity){
			//key java field is currently only used for entity keys.  won't work for databeans with a dynamically
			// created PK
			this.keyJavaField = ReflectionTool.getDeclaredFieldFromHierarchy(sampleDatabean.getClass(), keyFieldName);
			if(DrStringTool.isEmpty(params.getEntityNodePrefix())){
				throw new IllegalArgumentException("must specify entityNodePrefix for entity nodes");
			}
			this.entityNodePrefix = params.getEntityNodePrefix();
			this.entityNodeColumnPrefixBytes = DrByteTool.concatenate(StringByteTool.getUtf8Bytes(entityNodePrefix),
					new byte[]{ENTITY_PREFIX_TERMINATOR});
			EntityPrimaryKey<?,?> sampleEntityPrimaryKey = (EntityPrimaryKey<?,?>)samplePrimaryKey;
			this.ekFields = sampleEntityPrimaryKey.getEntityKey().getFields();
			this.ekPkFields = sampleEntityPrimaryKey.getEntityKeyFields();
			this.postEkPkKeyFields = sampleEntityPrimaryKey.getPostEntityKeyFields();
		}

		//info about PhysicalNodes, the leaf nodes that store the data (as opposed to virtual nodes)
		this.clientId = params.getClientId();
		if(entity){
			this.tableName = params.getPhysicalName();
			this.packagedTableName = null;//what to do here
			this.explicitNodeName = params.getParentName()+"."+sampleDatabean.getDatabeanName()+"."+entityNodePrefix;
		}else if(DrStringTool.notEmpty(params.getPhysicalName())){
			//explicitly set tableName.  do after entity check since that also sets a table name
			this.tableName = params.getPhysicalName();
			this.packagedTableName = params.getQualifiedPhysicalName();
			this.explicitNodeName = clientId.getName()+"."+tableName;
			logger.info("client:"+clientId.getName()+" "+sampleDatabean.getDatabeanName()+" overridden -> "+tableName);
		}else if(params.getBaseDatabeanClass() != null){//table-per-class-hierarchy (use superclass's table)
			this.tableName = params.getBaseDatabeanClass().getSimpleName();
			this.packagedTableName = sampleDatabean.getClass().getName();
			logger.info("client:"+clientId.getName()+" "+sampleDatabean.getDatabeanName()+" in superclass -> "
					+ tableName);
		}else{//default to using the databean's name as the table name
			this.tableName = sampleDatabean.getDatabeanName();
			this.packagedTableName = sampleDatabean.getClass().getName();
		}

		assertAssertions();
	}


	/***************************** methods **************************************************/

	public FieldSet<?> getScatteringPrefixPlusPrimaryKey(PK key){
		return new SimpleFieldSet<>(getKeyFieldsWithScatteringPrefix(key));
	}

	public List<Field<?>> getKeyFieldsWithScatteringPrefix(PK key){
		List<Field<?>> fields = new LinkedList<>();
		fields.addAll(sampleScatteringPrefix.getScatteringPrefixFields(key));
		if(key==null){
			return fields;
		}
		fields.addAll(key.getFields());
		return fields;
	}

	public Class<? extends Field> getFieldTypeForColumn(String columnName){
		Field<?> field = fieldByColumnName.get(columnName);
		return field.getClass();//throw NPE for invalid column name
	}

	public List<Field<?>> getPrimaryKeyFieldsWithValues(D databean){
		return sampleFielder.getKeyFields(databean);
	}

	public List<Field<?>> getFieldsWithValues(D databean){
		return sampleFielder.getFields(databean);
	}

	public List<Field<?>> getNonKeyFieldsWithValues(D databean){
		return sampleFielder.getNonKeyFields(databean);
	}

	private void addPrimaryKeyFieldsToCollections(){
		for(Field<?> field : DrIterableTool.nullSafe(primaryKeyFields)){
			this.primaryKeyFieldByName.put(field.getKey().getName(), field);
		}
	}

	private void addNonKeyFieldsToCollections(){
		for(Field<?> field : DrIterableTool.nullSafe(nonKeyFields)){
			this.nonKeyFieldByColumnName.put(field.getKey().getColumnName(), field);
		}
	}

	private void addFieldsToCollections(){
		for(Field<?> field : DrIterableTool.nullSafe(fields)){
			this.fieldByColumnName.put(field.getKey().getColumnName(), field);
			this.fieldByPrefixedName.put(field.getPrefixedName(), field);
			this.fieldNames.add(field.getKey().getName());
			java.lang.reflect.Field reflectionField = FieldTool.getReflectionFieldForField(sampleDatabean, field);
			this.reflectionFields.add(reflectionField);
			this.reflectionFieldByName.put(field.getKey().getName(), reflectionField);
		}
	}

	private void assertAssertions(){
		if(fieldAware){
			if(DrCollectionTool.notEmpty(nonKeyFields)){
				if(!fieldAware){
					logger.warn("found nonKeyFields on non-fieldAware databean "+sampleDatabean.getClass().getName());
				}
			}
		}
	}

	private FieldGeneratorType detectAutoGeneratedType(){
		List<Field<?>> fields = samplePrimaryKey.getFields();
		for (Field<?> field : fields) {
			if (field.getKey().getAutoGeneratedType().isGenerated()){
				setAutogeneratedFieldName(field.getKey().getName());
				return field.getKey().getAutoGeneratedType();
			}
		}
		return FieldGeneratorType.NONE;
	}


	/******************************** get/set **********************************************/

	public Class<PK> getPrimaryKeyClass(){
		return primaryKeyClass;
	}

	public PK getSamplePrimaryKey(){
		return samplePrimaryKey;
	}

	public Supplier<D> getDatabeanSupplier(){
		return databeanSupplier;
	}

	public D getSampleDatabean(){
		return sampleDatabean;
	}

	public Supplier<F> getFielderSupplier(){
		return fielderSupplier;
	}

	public F getSampleFielder(){
		return sampleFielder;
	}

	public boolean getFieldAware(){
		return fieldAware;
	}

	public List<Field<?>> getPrimaryKeyFields(){
		return primaryKeyFields;
	}

	public List<Field<?>> getNonKeyFields(){
		return nonKeyFields;
	}

	public List<Field<?>> getFields(){
		return fields;
	}

	public Map<String,Field<?>> getNonKeyFieldByColumnName(){
		return nonKeyFieldByColumnName;
	}

	public Map<String,Field<?>> getFieldByColumnName(){
		return fieldByColumnName;
	}

	public List<String> getFieldNames(){
		return fieldNames;
	}

	public List<java.lang.reflect.Field> getReflectionFields(){
		return reflectionFields;
	}

	public Map<String,java.lang.reflect.Field> getReflectionFieldByName(){
		return reflectionFieldByName;
	}

	public Map<String,Field<?>> getFieldByPrefixedName(){
		return fieldByPrefixedName;
	}

	public String getKeyFieldName(){
		return keyFieldName;
	}

	public List<Field<?>> getPrefixedPrimaryKeyFields(){
		return prefixedPrimaryKeyFields;
	}

	public Class<? extends ScatteringPrefix> getScatteringPrefixClass(){
		return scatteringPrefixClass;
	}

	public List<Field<?>> getScatteringPrefixFields(){
		return scatteringPrefixFields;
	}

	public ScatteringPrefix getSampleScatteringPrefix(){
		return sampleScatteringPrefix;
	}

	public Map<String,List<Field<?>>> getIndexes(){
		return indexes;
	}

	public Map<String,List<Field<?>>> getUniqueIndexes(){
		return uniqueIndexes;
	}

	public MySqlCollation getCollation(){
		return collation;
	}

	public MySqlCharacterSet getCharacterSet(){
		return characterSet;
	}

	public Map<String,Field<?>> getPrimaryKeyFieldByName(){
		return primaryKeyFieldByName;
	}

	public FieldGeneratorType getAutoGeneratedType(){
		return autoGeneratedType;
	}

	public boolean isManagedAutoGeneratedId(){
		return FieldGeneratorType.MANAGED.equals(autoGeneratedType);
	}

	public String getAutogeneratedFieldName(){
		return autoGeneratedFieldName;
	}

	public void setAutogeneratedFieldName(String autogeneratedFieldName){
		this.autoGeneratedFieldName = autogeneratedFieldName;
	}

	public void setFields(List<Field<?>> fields){
		this.fields = fields;
	}

	public MySqlCharacterSet getCharacter_set(){
		return characterSet;
	}

	public Class<PrimaryKeyFielder<PK>> getPrimaryKeyFielderClass(){
		return primaryKeyFielderClass;
	}

	public PrimaryKeyFielder<PK> getSamplePrimaryKeyFielder(){
		return samplePrimaryKeyFielder;
	}

	public String getTableName(){
		return tableName;
	}

	public String getExplicitNodeName(){
		return explicitNodeName;
	}

	public String getPackagedTableName(){
		return packagedTableName;
	}

	public ClientId getClientId(){
		return clientId;
	}

	public String getEntityNodePrefix(){
		return entityNodePrefix;
	}

	public byte[] getEntityColumnPrefixBytes(){
		return entityNodeColumnPrefixBytes;
	}

	public java.lang.reflect.Field getKeyJavaField(){
		return keyJavaField;
	}

	public boolean isEntity(){
		return entity;
	}

	public List<Field<?>> getEkFields(){
		return ekFields;
	}

	public List<Field<?>> getEkPkFields(){
		return ekPkFields;
	}

	public List<Field<?>> getPostEkPkKeyFields(){
		return postEkPkKeyFields;
	}
}
