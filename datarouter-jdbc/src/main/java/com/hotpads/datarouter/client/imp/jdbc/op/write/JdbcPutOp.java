package com.hotpads.datarouter.client.imp.jdbc.op.write;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import com.hotpads.datarouter.client.imp.jdbc.field.JdbcFieldCodec;
import com.hotpads.datarouter.client.imp.jdbc.field.codec.factory.JdbcFieldCodecFactory;
import com.hotpads.datarouter.client.imp.jdbc.node.JdbcNode;
import com.hotpads.datarouter.client.imp.jdbc.op.BaseJdbcOp;
import com.hotpads.datarouter.client.imp.jdbc.util.JdbcTool;
import com.hotpads.datarouter.client.imp.jdbc.util.SqlBuilder;
import com.hotpads.datarouter.config.Config;
import com.hotpads.datarouter.config.Isolation;
import com.hotpads.datarouter.config.PutMethod;
import com.hotpads.datarouter.exception.DataAccessException;
import com.hotpads.datarouter.exception.DuplicateEntrySqlException;
import com.hotpads.datarouter.serialize.fieldcache.DatabeanFieldInfo;
import com.hotpads.datarouter.serialize.fielder.BaseVersionedDatabeanFielder;
import com.hotpads.datarouter.serialize.fielder.DatabeanFielder;
import com.hotpads.datarouter.storage.databean.Databean;
import com.hotpads.datarouter.storage.databean.DatabeanVersioningException;
import com.hotpads.datarouter.storage.databean.VersionedDatabean;
import com.hotpads.datarouter.storage.field.Field;
import com.hotpads.datarouter.storage.field.FieldTool;
import com.hotpads.datarouter.storage.field.encoding.FieldGeneratorType;
import com.hotpads.datarouter.storage.field.generation.FieldGeneratorTool;
import com.hotpads.datarouter.storage.field.imp.comparable.LongField;
import com.hotpads.datarouter.storage.key.primary.PrimaryKey;
import com.hotpads.datarouter.util.core.DrCollectionTool;
import com.hotpads.util.core.iterable.BatchingIterable;
import com.mysql.jdbc.MysqlErrorNumbers;

public class JdbcPutOp<
		PK extends PrimaryKey<PK>,
		D extends Databean<PK,D>,
		F extends DatabeanFielder<PK,D>>
extends BaseJdbcOp<Void>{

	private final JdbcNode<PK,D,F> node;
	private final DatabeanFieldInfo<PK,D,F> fieldInfo;
	private final JdbcFieldCodecFactory fieldCodecFactory;
	private final Collection<D> databeans;
	private final Config config;

	public JdbcPutOp(JdbcNode<PK,D,F> node, JdbcFieldCodecFactory fieldCodecFactory, Collection<D> databeans,
			Config config) {
		super(node.getDatarouter(), node.getClientNames(), getIsolation(config), shouldAutoCommit(databeans, config));
		this.node = node;
		this.fieldInfo = node.getFieldInfo();
		this.fieldCodecFactory = fieldCodecFactory;
		this.databeans = DrCollectionTool.nullSafe(databeans);
		this.config = Config.nullSafe(config);
	}

	@Override
	public Void runOnce(){
		Connection connection = getConnection(node.getClientId().getName());
		int batchSize = config.getIterateBatchSize();
		if(fieldInfo.getIsVersioned() && !fieldInfo.getAutoGeneratedType().isGenerated()){
			for(D databean : databeans){
				VersionedDatabean<PK,?> versionedDatabean = (VersionedDatabean<PK,?>)databean;
				D existingDatabean = node.get(databean.getKey(), null);
				if(existingDatabean == null){
					if(versionedDatabean.getVersion() != 0){
						throw new DatabeanVersioningException();
					}
					versionedDatabean.incrementVersion();
					try{
						jdbcInsert(connection, databean);
					}catch(DuplicateEntrySqlException exception){
						throw new DatabeanVersioningException(exception);
					}
				}else{
					VersionedDatabean<PK,?> existingVersionedDatabean = (VersionedDatabean<PK,?>)existingDatabean;
					if(existingVersionedDatabean.getVersion() != versionedDatabean.getVersion()){
						throw new DatabeanVersioningException();
					}
					versionedDatabean.incrementVersion();
					jdbcUpdate(connection, databean, false);
				}
			}
		}else if(PutMethod.INSERT_ON_DUPLICATE_UPDATE == config.getPutMethod()
				&& !fieldInfo.getAutoGeneratedType().isGenerated()){
			for(List<D> databeanBatch : new BatchingIterable<>(databeans, batchSize)){
				jdbcInsertOnDuplicateKeyUpdate(connection, databeanBatch);
			}
		}else{
			for(D databean : databeans){
				jdbcPutUsingMethod(connection, databean, config.getPutMethod());
			}
		}
		return null;
	}

	/******************** private **********************************************/

	private static Isolation getIsolation(Config config){
		if(config==null){
			return Config.DEFAULT_ISOLATION;
		}
		return config.getIsolationOrUse(Config.DEFAULT_ISOLATION);
	}

	private static boolean shouldAutoCommit(Collection<? extends Databean<?,?>> databeans, final Config config){
		if(DrCollectionTool.size(databeans) > 1){
			return false;
		}
		return Config.nullSafe(config).getPutMethod().getShouldAutoCommit();
	}

	private void jdbcPutUsingMethod(Connection connection, D databean, PutMethod putMethod){
		Optional<Field<?>> generatedField = FieldGeneratorTool.optFieldToGenerate(fieldInfo, databean);
		if(generatedField.isPresent()){
			if(fieldInfo.getAutoGeneratedType() == FieldGeneratorType.RANDOM){
				FieldGeneratorTool.generateAndSetValueForField(fieldInfo, databean, generatedField.get(),
						bean -> tryJdbcInsertGeneratedId(connection, bean));
			}else{ // The RDBMS will assign the id.
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.INSERT_OR_BUST == putMethod){
			jdbcInsert(connection, databean);
		}else if(PutMethod.UPDATE_OR_BUST == putMethod){
			jdbcUpdate(connection, databean, false);
		}else if(PutMethod.INSERT_OR_UPDATE == putMethod){
			try{
				jdbcInsert(connection, databean);
			}catch(RuntimeException e){
				//TODO this will not work inside a txn if not all of the rows already exist
				jdbcUpdate(connection, databean, false);
			}
		}else if(PutMethod.UPDATE_OR_INSERT == putMethod){
			try{
				jdbcUpdate(connection, databean, false);
			}catch(RuntimeException e){
				//TODO this will not work inside a txn if some of the rows already exist
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.MERGE == putMethod){
			//not really a jdbc concept, but usually an update (?)
			try{
				jdbcUpdate(connection, databean, false);
			}catch(RuntimeException e){
				jdbcInsert(connection, databean);
			}
		}else if(PutMethod.INSERT_IGNORE == putMethod){
			jdbcInsert(connection, databean, true);
		}else if(PutMethod.UPDATE_IGNORE == putMethod){
			jdbcUpdate(connection, databean, true);
		}else{
			boolean alreadyExists = node.exists(databean.getKey(), null);
			if(alreadyExists){//select before update like hibernate's saveOrUpdate
				jdbcUpdate(connection, databean, false);
			}else{
				jdbcInsert(connection, databean);
			}
		}
	}

	private boolean tryJdbcInsertGeneratedId(Connection connection, D databean){
		try{
			jdbcInsert(connection, databean);
			return true;
		}catch(DuplicateEntrySqlException e){
			return false;
		}
	}

	private void jdbcInsert(Connection connection, D databean){
		jdbcInsert(connection, databean, false);
	}

	private void jdbcInsert(Connection connection, D databean, boolean ignore){
		StringBuilder sb = buildBaseInsertStatement(Collections.singletonList(databean), ignore);
		try{
			Statement ps = executeInsertStatement(connection, sb.toString(), Collections.singletonList(databean));
			// set autogenerated id
			if(fieldInfo.isManagedAutoGeneratedId()){
				//Retrieve the generated id from DB
				ResultSet resultSet = ps.getGeneratedKeys();
				resultSet.next();
				Long id = resultSet.getLong(1);
				//set the id
				FieldGeneratorTool.setAutoGeneratedId(fieldInfo, databean, id);
			}
		}catch(Exception e){
			if(e instanceof SQLException && ((SQLException) e).getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){
				throw new DuplicateEntrySqlException(e);
			}
			throw new DataAccessException("error inserting into "+node.getTableName(),e);
		}
	}

	private void jdbcInsertOnDuplicateKeyUpdate(Connection connection, Collection<D> databeans){
		StringBuilder sb = buildBaseInsertStatement(databeans, false);
		sb.append(" on duplicate key update ");
		boolean doneOne = false;
		for(Field<?> field : fieldInfo.getFields()){
			if(doneOne) {
				sb.append(",");
			}
			sb.append(field.getKey().getColumnName() + "=VALUES(" + field.getKey().getColumnName() + ")");
			doneOne = true;
		}
		try{
			executeInsertStatement(connection, sb.toString(), databeans);
		}catch(Exception e){
			if(e instanceof SQLException && ((SQLException) e).getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){
				throw new DuplicateEntrySqlException(e);
			}
			throw new DataAccessException("error inserting into "+node.getTableName(),e);
		}
	}

	private Statement executeInsertStatement(Connection connection, String sql, Collection<D> databeans)
			throws SQLException{
		PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		int parameterIndex = 1;//one based
		for(D databean : databeans){
			List<Field<?>> fields = fieldInfo.getFieldsWithValues(databean);
			for(JdbcFieldCodec<?,?> codec : fieldCodecFactory.createCodecs(fields)){
				codec.setPreparedStatementValue(ps, parameterIndex);
				++parameterIndex;
			}
		}
		ps.execute();
		return ps;
	}

	private StringBuilder buildBaseInsertStatement(Collection<D> databeans, boolean ignore){
		StringBuilder sb = new StringBuilder();
		sb.append("insert");
		if(ignore){
			sb.append(" ignore");
		}
		sb.append(" into "+node.getTableName()+" (");
		FieldTool.appendCsvColumnNames(sb, fieldInfo.getFields());
		sb.append(") values ");
		boolean doneOne = false;
		for(int count = 0 ; count < databeans.size() ; count++){
			if(doneOne){
				sb.append(",");
			}
			sb.append("(");
			JdbcTool.appendCsvQuestionMarks(sb, fieldInfo.getFields());
			sb.append(")");
			doneOne = true;
		}
		return sb;
	}

	private void jdbcUpdate(Connection connection, D databean, boolean ignore){
		//it doesn't make sense to update a row without PK fields.  updating the PK will move the row
		List<Field<?>> emptyNonKeyFields = fieldInfo.getNonKeyFields();
		if(DrCollectionTool.isEmpty(emptyNonKeyFields)){
			return;
		}

//		logger.warn("JDBC update");
		StringBuilder sb = new StringBuilder();
		sb.append("update "+node.getTableName()+" set ");
		SqlBuilder.appendSqlUpdateClauses(sb, emptyNonKeyFields);
		sb.append(" where ");
		List<Field<?>> whereFields = new ArrayList<>(databean.getKeyFields());
		if(fieldInfo.getIsVersioned()){
			VersionedDatabean<PK,?> versionedDatabean = (VersionedDatabean<PK,?>)databean;
			whereFields.add(new LongField(BaseVersionedDatabeanFielder.FieldKeys.version,
					versionedDatabean.getVersion() - 1));
		}
		sb.append(SqlBuilder.getSqlNameValuePairsEscapedConjunction(fieldCodecFactory, whereFields));
		int numUpdated;
		try{
			PreparedStatement ps = connection.prepareStatement(sb.toString());
			int parameterIndex = 1;
			List<Field<?>> nonKeyFields = fieldInfo.getNonKeyFieldsWithValues(databean);
			for(JdbcFieldCodec<?,?> codec : fieldCodecFactory.createCodecs(nonKeyFields)){
				codec.setPreparedStatementValue(ps, parameterIndex);
				++parameterIndex;
			}
			numUpdated = ps.executeUpdate();
		}catch(SQLException e){
			throw new DataAccessException("error updating "+node.getTableName(), e);
		}
		if(!ignore){
			if(numUpdated != 1){
				if(fieldInfo.getIsVersioned()){
					throw new DatabeanVersioningException();
				}
				throw new DataAccessException(node.getTableName() + " row " + databean.getKey().toString()
						+ " not found so could not be updated");
			}
		}
	}
}
